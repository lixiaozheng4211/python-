import random as r
import turtle as t
t.tracer(0)
t.hideturtle()
date=['\u2665Av47','\u26652v51','\u26653v03','\u26654v08','\u26655v11','\u26656v15','\u26657v19','\u26658v23','\u26659v27','\u266510v31','\u2665Jv35','\u2665Qv39','\u2665Kv43',
    '\u2660Av48','\u26602v52','\u26603v04','\u26604v07','\u26605v12','\u26606v16','\u26607v20','\u26608v24','\u26609v28','\u266010v32','\u2660Jv36','\u2660Qv40','\u2660Kv44',
    '\u2666Av45','\u26662v49','\u26663v01','\u26664v05','\u26665v09','\u26666v13','\u26667v17','\u26668v21','\u26669v25','\u266610v29','\u2666Jv33','\u2666Qv37','\u2666Kv41',
    '\u2663Av46','\u26632v50','\u26633v02','\u26634v06','\u26635v10','\u26636v14','\u26637v18','\u26638v22','\u26639v26','\u266310v30','\u2663Jv34','\u2663Qv38','\u2663Kv42',
    '小王v53','大王v54']
 
dz=[]
lm1=[]
lm2=[]
#----------------------------------------------------------------------------排序+分牌--------------------------------------------------------------------------------
#=================================================================================分牌================================================================================
def shu(x,name):
    for j in range(x):
        an=r.randint(0,len(date)-1)
        name.append(date[an])
        del date[an]
#============================================================================排序=======  # 选择排序
    for j in range(x-1):
        for i in range(x-1-j):
            if int(name[j][-2:])<=int(name[j+1+i][-2:]) :#数倒序，因为从正序排的话，有10的加入会导致字符串的顺序发生改变
                name[j],name[j+1+i]=name[j+1+i],name[j]
#分牌之后就排序有效避免了画牌的时候不知道牌的顺序：直接分出一副有序的扑克牌注意！！！！！！
shu(20,dz)
shu(17,lm1)
shu(17,lm2)

###位移-----------------------
def lc(x,y):
    t.penup()
    t.goto(x,y)
    t.pendown()
#####方框-------------
def gezi(a,b,c):
    x=0
    while x<=c :
        t.penup()
        t.goto(a+x,b)
        t.pendown()
        t.seth(-90)
        t.begin_fill()
        t.color("grey","lightgrey")
        for i in range(2):
            t.forward(85)
            t.circle(-10,90)
            t.forward(55)
            t.circle(-10,90)
            x+=18
        t.end_fill()
gezi(-475,100,684)
gezi(-400,-50,576)
gezi(-400,-170,576)
t.tracer(10,0)
####规定颜色---------------
def color(name):
    if name[i][0:1]=='\u2665' or name[i][0:1]=='\u2666' or name[i][0:1]=="大" :
        t.pencolor("red")
    elif name[i][0:1]=='\u2660' or name[i][0:1]=='\u2663' or name[i][0:1]=="小" :
        t.pencolor("black")
####数字------------------
def zi(name,x,y):
    a=['J','O','K','E','R']
    if name[i][1:3]=="10" :
        lc(x+36*i,y)
        t.write(name[i][1:3],font=("微软雅黑",15))
    elif name[i][1:2]=="王" :
        for j in range(5):
            lc(x+36*i+5,y-(15*j))
            t.write(a[j],font=("华文琥珀",16))
        lc(x+36*i,y-75)    
    else:
        lc(x+36*i,y)
        t.write(name[i][1:2],font=("微软雅黑",15))
##图形--------------

    if name[i][1:2]!="王" :
        lc(x+36*i,y-30)
        t.write(name[i][0:1],font=("微软雅黑",24))
######汇总-----------
for i in range(20):
    color(dz)
    zi(dz,-545,80)
for i in range(17):
    color(lm1)
    zi(lm1,-470,-70)
    color(lm2)
    zi(lm2,-470,-190)
#地主与爱心-------------
lc(165,83)
t.pencolor("black")
t.write("地主",font=("微软雅黑",12))
lc(160,3)
if dz[19][0:1]=='\u2665' or dz[19][0:1]=='\u2666' or dz[19][0:1]=="大" :
        t.pencolor("red")
elif dz[19][0:1]=='\u2660' or dz[19][0:1]=='\u2663' or dz[19][0:1]=="小" :
        t.pencolor("black")
t.write(dz[19][0:1],font=("微软雅黑",50))
t.tracer(10,0)
t.done()

                


'''现在我需要学习的点:
    1.字符串的切片    ok
    2.这种分块的思维方式    ing:
        这种模块化的方式主要策略就是拆分
        将呈现到我面前的对象查拆分成很多种
        元素然后将每种元素及其实现的方式写
        出来就拿这个扑克牌的作业来说最后呈
        现到我面前的对象就是一副已经排好序
        的扑克牌，在这之中所包含的元素有不
        同的花色不同的数值不同的颜色并且我
        还观察到数字的颜色跟花色的颜色是相
        同的但是不同的花色有不同的颜色，那
        么我就应该把有相同点的对象放在一起
        定义成一个函数
    
    3.t.tracer的使用方法   ok,虽然最后还是用了time.sleep的函数'''

    
